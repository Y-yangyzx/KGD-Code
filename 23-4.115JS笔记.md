### JS

##### 前置基础

* 编程：让计算机为了解决某种问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。          计算机程序：计算机所执行性的一系列的指令集合
* 计算机语言：人与计算机之间通讯的语言    分类：机器语言、汇编语言、高级语言。
* 编程语言：类似于人类的语言来控制计算机
* 
* JS定义：是一种运行在客户端的脚本语言   不需要编译，运行过程中由JS引擎逐行进行解释并执行
* 浏览器由两部分组成：渲染引擎（内核）和JS引擎

##### 知识点---基础知识

* JS组成：ECMAScript、DOM（文档对象模型）、BOM（浏览器对象模型）

* 书写方式：行内式、内嵌式、外链式（两个Script表情中不要有代码）

* JS代码推荐使用单引号！

* 注释：单行和多行

* 输入输出语句：
       输出：alert()         console.log()       document.write()  输入：prompt()

* 变量：保存数据用的    通过变量名获取使用和修改数据      用来存放数据用的容器
       本质：在内存中申请一块空间来存储数据用的
        变量如何使用？声明（空的空间）、赋值   var（系统会自动分配空间）

* 变量语法扩展：
       变量更新：原有的值被覆盖
       同时声明多个变量：只需要写一个var，多个变量名之间使用英文逗号分隔开
       声明变量三种特殊情况：undefind（只声明未赋值）、报错（不声明不赋值使用）、可以输出（不声明直接赋值---不推荐）

* 变量命名规范（标识符）     驼峰命名法

* 例子：交换两个变量的值

* 

* 数据类型：
     为什么需要数据类型？**不同的数据所需要占据的存储空间是不同的**，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，所以定义了不同的数据类型。   根据数据占据空间大小的不同，分成不同类型的数据
      变量的数据类型：弱语言，js的变量类型只有在程序运行时，根据等号右边的值才能确定是什么类型       js是动态语言，变量的数据类型是可以改变的

* 简单数据类型和
      基本数据类型：Number（数字型）、Boolean、String、Undefind、Null

* Number（数字型）

   数字前加0 代表8进制   加0x代表16进制
          JS中数值的最大值和最小值：Number.MAX_VALUE      Number.MIN_VALUE
          三个特殊值：Infinity：无穷大、-Infinity：无穷小、NaN：非数字
          isNaN()：方法  判断是否是数字   是数字返回false   不是数字返回true

* String（字符串类型）
         推荐使用单引号    单套双或双套单
         字符串转义字符： \n换行（js中换行  不用br）    要写在引号里
         字符串长度及拼接：
                 length属性：判断字符串长度 
                 字符串拼接：+     字符串+任意类型=拼接成了一个字符串           加强：+变量  ES6加强语法

* Boolean类型
         true和false     做加法时，true当1来看，false当0来看

* Undefind
         变量声明未赋值     未定义的数据类型
         undefind和数字相加    NaN

* Null
        空值  里面值为空
        Null和数字相加   结果还是那个数字

* typeof检测变量数据类型       语法：typrof  变量名
       null 是object类型          在输入框中输入的内容是字符串型的

* 字面量：通俗来说，字面量表示如何表达这个值

* 

* 数据类型的转换：通过表单、prompt获取过来的数据默认是字符型的，此时不能直接简单的进行加法运算。
      常用三种转换方式：转为字符串类型、转为数字型、转为布尔型
            转为字符串类型：toStirng()        String()强制转换           加号拼接字符串+''√ （隐式转换）
            转为数字型：parseInt(string)转成整数数值型 取整 会去掉px单位（以数字开头）    parseFloat(string)转成浮点数数值型   Number()强制转换函数    隐式转换- * /（+会拼接其他会转成数字）
            转为布尔型：Boolean()    ''、0、null、NaN、undefined  （空的否定的---false）  除了这5个都是true

* 运算符

* 流程控制语句

* switch语句：根据不同条件来执行不同的代码      针对一系列特定值来书写
      语法结构：switch(表达式){

  ​                           case value1:

  ​                                 执行语句；
  ​                                 break;
  }
  value要与表示式相匹配    匹配上执行语句
  ​    注意事项：开发中经常将表达式写成变量     要全等才能匹配上===      break如果当前没有，会继续执行

* 断点调试：Sources中行号前点击  刷新  F11

* 变量命名规范：变量---名次    方法---动词    操作符规范：左右两侧各留一个空格     但行注释后留一个空格再写注释的代码

* 

* 数组
      定义：一组数据的集合     将一组数据放在一个变量下
      创建数组：1）new  var arr = new Array();//创建了一个空的数组        2） 数组字面量创建数组√         var arr = [];
      数组中新增元素：通过修改length长度    length属性是可以读写的   不给值默认是：undefind
                                     通过修改数组索引新增数组元素 arr[4] = '比原数组长度长，可以直接加';  添加、占用
                       不要直接给数组名赋值，否则整个数组变成你付的新值了。
      JS中可以直接用console.log()输出数组中的每一个元素

* 筛选数组：1、循环   2、newArr.length（从无到有  依次递增）       经验的积累（举一反三）

* 翻转数组：往一个新数组里放  倒着取

* 冒泡排序：一种算法（观察执行过程，找到规律）  把一些列的数据按照一定的顺序进行排列显示
         两两比较，顺序错误交换  之后继续比较   先把最大的（或最小的）放到最后
         交换的趟数、里面交换的次数   几个元素趟数就是元素个数-1     次数规律：arr.length-i-1

* 

* 函数：（榨汁机）
     为什么使用函数？有很多功能相似的代码，并且要重复使用              

     使用目的：代码重用

     使用：命名函数声明函数： function 函数名(){函数体} 函数名一般是动词      调用函数：函数名();

  ​            函数表达式声明函数：var 变量名 = function(){};
     函数的封装：把一个或多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口

* return关键字
        把函数的结果返回给调用者   终止函数只能返回一个值，返回的是最后一个值    返回多个值可以返回数组
        没有return则返回undefined

* arguments使用     参数里边一个都不写了

  当我们不确定有多少个参数传递的时候，可以用arguments来获取 

  当前函数的一个内置对象，所有函数都内置了这个对象，**存储了传递的所有实参**     以一种伪数组的方式来展示     伪数组：具有数组的length的属性、按照索引的方式存储、没有真正数组的一些方法
  案例：利用函数求任意个数的最大值

* 案例：输出2月份的天数   （体会函数调用函数）

* JS中的作用域：
      变量在某个范围起作用和效果  目的是为了提高程序的可靠性更重要的是解决命名冲突问题
      全局作用域：整个script标签中      局部作用域：**在函数内部**就是局部作用域
      全局变量：全局作用域下的变量         局部变量：在局部作用域下的变量 （形参也算是局部变量）     特殊情况：如果在函数内部没有声明直接赋值的变量是全局变量。        从执行效率来看：全局变量只有浏览器关闭的时候才会销毁（比较占据资源），局部变量当程序执行完毕就会销毁（比较节约资源）

* JS块级作用域是ES6新增的   {}包含的

* 作用域链：链式查找方式（就近原则）          内部函数访问外部函数的变量，采取链式结构查找

* 预解析（JS运行机制）  P141-142
      JS引擎运行js分两步：预解析       代码执行
            预解析：js引擎会把js里面所有的var还有function提升到当前作用域的最前面     分为：变量预解析（变量提升）和函数预解析（函数提升）
               变量提升：把所有的变量声明提升到当前的作用域最前面   不提升赋值操作
               函数提升：把所有函数声明提升到当前作用域的最前面     不提升调用函数

  ​         代码执行：按照顺序从上往下执行
  ​      函数表达式调用必须写在函数表达式的下面

* 

* 

* 对象
      什么是对象？是一个具体的事物（一个数据库、一张网页、一个远程服务器的连接）
      对象是一组无序的相关属性和方法的集合   所有事物都是对象    属性：事物的特征    方法:事物的行为
      为什么需要对象？想要保存一个人的完整信息怎么做   可以用数组但不好（会有歧义表达不清晰  同时数组无法表示方法）  而对象让这个结构更清晰强大

* 创建对象的三种方式
      利用对象字面量：{里面包含了对象的属性和方法}   var obj = {};//创建了一个空对象    键值对的形式：键--属性名：值--属性值（可以是任何类型）;    多个属性之间用，隔开       方法：后的跟的是一个匿名函数
      利用new Object创建对象：
      利用构造函数创建对象：

* 使用对象的属性：1）对象名.属性     .理解为的         2）对象名['属性名']     []必须加''
  使用对象的方法：对象名.方法名() 

* 利用new Object()方式创建对象
   var obj = new Object();  依次的给对象的属性方法赋值    obj.name = "zs";  obj.age = 18;……

* 使用构造函数创建对象，为什么？前两种创建对象的方式一次只能创建一个对象
    语法：function 构造函数名(参数){this.属性=值；this.方法 = function(){}}；    创建对象：new 构造函数名(参数);   
    1）构造函数首字母要大写 2）不需要return就可以返回结果  3）调用构造函数时必须使用new  4）属性和方法前必须添加this
    构造函数和对象：构造函数相当于C#中的类，创建的对象我们也称之为对象实例化

* new关键字执行过程
  1）new构造函数可以在内存中创建一个空的对象   2）this会指向刚才创建的空对象    3）执行构造函数中的代码，给这个对象添加属性和方法   4）返回这个对象

* 变量属性、函数方法的区别
  变量和属性相同点：都是用来存储数据的
                     不同点：变量单独声明并赋值  使用的时候直接写变量名  单独存在       属性在对象里面不需要声明的 使用的时候必须是 对象.属性
  函数和方法相同点：都是实现某种功能 做某件事
                     不同点：函数是单独声明 掉用函数名()  单独存在        方法是在对象中  调用对象.方法()

*   

* 内置对象

  JS中对象分为三种：自定义对象、内置对象、浏览器对象
  系统内部已经写好了的对象，JS一些自带的对象
  MDN文档---查看内置对象

* Math对象
  不是一个构造函数，所以不需要new可以直接调用里面的属性和方法（静态的）
  属性：PI    
  方法：max()   min()   abs()绝对值（隐式转换  会把字符串型的-1转换为数字型）  floor()向下取整    ceil()向上取整      round()四舍五入（.5 特殊  .5往大了取  例：-1.5  取成-1）    
  随机数方法：random() 返回一个随机的小数[0,1) 没有参数     得到两个数之间的随机整数并且包含这两个数公式：Math.floor(Math.random()*(max-min+1))+min;     

* 日期对象 Date
  是一个构造函数，必须new才能创建日期对象     var date = new Date();  ---没有参数，返回当前时间
                参数常用写法：数字型  2023,04,03    字符串型 '2023-04-3 15:08:10'  √
  格式化日期：方法  getFullYear()   getMonth() 0-11月     getDate()几号    getDay()星期几(周日返回的是0)   getHours()       getMinutes()       getSeconds() 
  时间戳：获取日期的总毫秒形式   Date对象是基于1970年1月1日过了多少毫秒       永远不会重复
                 valueOf()          getTime()  这个两个是对象的方法（需要先new一个对象出来）  现在时间距离1970年1.1过了多少毫秒      简单写法： var date = +new Date();         H5新增：Date.now()

* 数组对象  Array
  var arr1 = new Array();表示创建了一个空数组        var arr2 = new Array(2);表示数组长度是2  里面有两个空元素        var arr3 = new Array(2,3);表示里面有两个元素2、3
  检测是否为数组：1）instanceof  运算符  arr instanceof Array 返回的是布尔类型     2）Array.isArray(参数)  返回布尔类型   H5新增的
  添加元素：push()   在数组末尾添加一个或多个数组元素   push 推  给数组追加新的元素        返回值：新数组的长度  原数组也会相应变化
                     unshift()  在数组开头添加一个或多个数组元素       返回值：新数组的长度  原数组也会相应变化
                     pop()    删除数组最后一个元素（一次只能删除一个）  不写参数      返回值：删除的那个元素
                     shift()    删除数组第一个元素（一次只能删除一个）     不写参数      返回值：删除的那个元素
  数组排序：

  ​                   reverse()  翻转数组方法
  ​                   sort()   数组排序      sort(function(a,b){return a-b;}) //升序         降序：b-a 
  数组索引方法：
  ​                   indexOf()    返回数组中满足条件的第一个索引号   找不到返回-1
  ​                   lastIndexOf()   返回数组中满足条件的最后一个索引号    找不到返回-1     从后面开始查找
  数组去重案例（重点）：遍历旧数组，看新数组中有没有  indexOf()如果为-1则证明没有该元素就添加到新数组中  push方法
  数组转为字符串：toString()方法 arr.toString()        join(分隔符) 什么都不写默认是逗号（最后一个没有）
  补充：concat()连接两个或多个数组 返回一个新数组  不影响原数组      slice(begin,end)数组截取 返回被截取项目的新数组    splice() 数组删除 从第几个开始，要删除几个   返回被删除项目的新数组，会影响新数组 

* 字符串对象
  复杂数据类型才有属性和方法  但是string有      
  基本包装类型：把简单数据类型包装成了复杂数据类型，这样他就可以有属性和方法了    三种基本包装类型：Stirng、Number、Boolean
  字符串的不可变性：空间中新开辟空间       不要大量拼接字符串
  常用方法：根据字符返回位置：indexOf('要查询的字符',[查找的起始位置])        lastIndexOf() 
                    
  案例：统计字符串中o的位置以及次数   P181-P186

* 

* 简单数据类型和复杂数据类型
  值类型               引用类型
  null返回的是一个空对象 object       如果有个变量打算存储数据，但又没想好，可以给null
  堆和栈
  值类型（简单数据类型）直接放在栈中  栈中存放的是值
  引用类型（复杂数据类型） 地址放在栈中指向堆中的值   值放在堆中

* 简单数据类型传参     直接把值传了进去（复制了一份），不会影响到外面的值
  复杂数据类型传参     P190

* 

* WebAPIs 
   API：一种工具，以便能轻松实现想要实现的功能      一般是函数
  Web API是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM）

* DOM
  什么是DOM？文档对象模型   编程接口  W3C提供了一系列的接口，通过这些接口可以改变网页的内容、结构和样式。
  DOM树：把整个网页看成一个DOM树

* 获取元素：通过id获取：getElementById();     参数：字符串  获取到了整个标签  返回的是一个元素对象
     console.dir(); 打印返回的元素对象  跟好的查看里面的属性和方法
                        通过标签名获取：getElementsByTagName()   返回带有指定标签名的**对象的集合**  得到元素是动态的      即使只有1个或没有li  返回的也是一个数组（伪数组）   
                            通过父元素获取内部所有指定标签名的子元素       element.getElementsByTagname('标签名')    父元素必须是单个元素（不能是维数组的形式），获取的时候不包含父元素本身
     
* 通过HTML5（I9以上支持）新增的方法获取
     通过类名获取元素：getElementsByClassName('类名')
     返回指定选择器第一个元素：querySelector('选择器')  类 .box   id #box  里面的选择器要加符号
     返回指定选择器所有元素：querySelectorAll('选择器') 

* 获取特殊元素：body和html
     document.body      返回的是元素对象
     document.documentElement      返回的是html元素对象

* 事件
     定义：可以理解为被js监测到的行为    触发---响应机制          比如：点击事件
     事件由三部分组成（三要素）：事件源、事件类型、事件处理程序
               事件源：事件被触发的对象   比如：按钮
               事件类型：如何触发    什么事件    比如：鼠标经过、键盘按下、鼠标点击
               事件处理程序：要做什么事儿        通过函数赋值的方式    完成 

* 执行事件的步骤：
     1、获取事件源
     2、注册事件（绑定事件）
     3、添加事件处理程序（采取函数赋值形式）

* 常见鼠标事件---截图

* 操作元素----一些属性

     改变元素的内容：element.innerText 修改元素的内容    不识别HTML标签   还会去除换行和空格    
                                    element.innerHTML    识别HTML标签   W3C标准   显示全部内容包含HTML标签   保留空格和换行
                                    这两个元素是可读写的  可以获取元素里面的内容

* 修改表单元素
     需要通过value修改的   比如：input.value = "被点击了";          禁用按钮：btn.disabled = ture;
     this指向的是事件函数的调用者

* 案例：点击眼睛按钮明文显示
     flag变量     先布局再写js

* 修改元素样式属性
     element.style.属性 = '';      注意加style     属性是驼峰命名法 background-color----backgroudColor
     JS修改style样式操作产生的是行内样式，css权重较高

*  案例：点击x关闭二维码图片
     diplay是盒子的属性，隐藏的是盒子  注意语法格式：

     ```javascript
       var obox= document.querySelector('.box')
             var odel = document.querySelector('#del');
             odel.onclick=function(){
                 obox.style.display='none';//none要加上''
             }
     ```

* 案例：虚幻遍历精灵图
     for循环     背景位置：backgroud-postion:'';     索引号*44得到y坐标，注意是负的

* 案例：显示隐藏文本框中的内容
     获得焦点----onfocus事件     失去焦点----onblur事件

* 通过className更改元素属性 
     样式比较多、功能比较复杂的情况下使用
     element.className       给当前元素加上一个change这个类时      会覆盖掉原来的类名  想要保留呢？this.className='first chage'  留个空格加上新的类   多类名选择器

* *案例：密码框验证（提示信息  比如：位数不够、符号非法……）
     失去焦点时判断   样式较多可以使用类名

* 总结：操作元素
     操作**元素内容**：innerText、innerHTML
     操作**常见元素**属性：src、href、title、alt等
     操作**表单元素**属性：value、type、disabled等
     操作**元素样式**属性：element.style（样式较少）       element.className（样式较多）

* 排他思想
     触发点击事件时，先把所有按钮的颜色去掉（循环），然后再将点击的按钮添加颜色

* 案例：换肤效果
     先遍历  将点击图片中的内容添加到背景图片上  document.body.style.backgroudImage='url('+this.src+')';
     记住：''  在引号中++  在++中放变量

* 隔行变色
     操作的是tr     当鼠标经过时加上一个类（这一行文本变成某个颜色）    鼠标离开时清除掉这个类  循环

* 全选取消全选案例
     分成两大步：上面全选选中 下面都被选中           下面有一个没被选中 剩下的不会被选中了都选中了才会选中
     flag控制全选按钮是否被选中      break      
     思想：循环遍历，如果有没有选中的，flag=false；  如果遍历完了没有未被选中的，flag就是默认值true                       最后在循环之后把flag的值赋给全选按钮的checkd

* 获取自定义属性值：element.属性（获取元素自带属性值  内置的）            element.getAttribute('属性')（程序员自己添加的属性  自定义属性）  
     设置自定义属性：element.setAttribute('属性','值');   主要针对自定义属性     class这里面写的就是class
     移除自定义属性：element.removeAttribute('属性','值');

* tab栏切换：p223-p225

* 自定义属性目的：为了保存并使用数据，有些数据可以保存到页面中而不用保存到数据库中。p227

* 

* 节点操作
     目的：获取元素  更简单          之前：利用DOM提供的方法获取元素
     节点：页面所有元素都是节点         组成：节点类型、节点名称、节点值

* 节点之父节点

     ​       node.parentNode      得到的是离元素最近的父节点  如果找不到就返回为null
     节点之子节点
     ​       node.childNodes（标准）得到所有的子节点包含元素节点和文本节点      想要只得到元素节点：nodeType判断是否是元素节点---1是元素节点      文本节点是3

     ​       node.children（非标准）  重点掌握   只得到元素节点
     ​      获取第一个子元素：firstChild            获取第一个子元素节点：firstElementChild
     ​      获取最后一个子元素：lastChild         获取最后一个子元素节点：lastElementChild
     ​      实际开发中：element.children[i]     ol.children.length-1最后一个元素索引号

* 案例：下拉菜单

* 兄弟节点

* 创建节点和添加节点
     document.createElement('tagName');       创建节点---添加节点        node.appendChild(child)  后面追加元素  类似于数组中的push       node.insertBefore(child,指定元素)      添加节点
     node父级       child子级
     想在页面添加一个新的元素：1.创建元素   2.添加元素

* 案例：P234

* 

* 

* 

* DOM重点核心
     我们获取过来的DOM元素就是一个对象，所以成为文档对象模型

     针对元素的操作主要有：创建、增删改查、属性的操作、事件的操作
     创建元素：

     ……

* 事件高级
     注册事件（绑定事件）  两种方式：传统方式和方法监听注册方式
                         btn.onclick=function(){}  特点：注册事件的唯一性  同一个元素一个事件只能设置一个处理函数
                         addEventListener(type,listener[,useCapture])是一个方法    特点：同一个元素一个事件可以注册多个监听器（事件处理程序）       这里的type不用带on    listener：事件处理**函数**（监听器）  fn不要加()
     attachEvent监听事件  I9以前使用

* 删除事件
     传统方式解绑事件：eventTarget.onclick = null;
     eventTarget.removeEventListener(type,listener[,useCapture]);     第二个参数：函数的名字

* 事件流理论：
     事件流：描述的是从页面接收事件的顺序             事件发生时会在元素节点之间按照特定的顺序传播，这个传播的过程即DOM事件流
     DOM事件流分为三个阶段：

     1.捕获阶段

     2.当前目标阶段

     3.冒泡阶段
     事件流代码验证P252

* 事件对象
     event就是一个事件对象  写到侦听函数的小括号里 当成形参看
     事件对象只有有了事件才会存在 它是系统给我们自动创建的，不需要我们传递参数
     事件对象是我们事件一系列相关数据的集合  跟事件相关的 比如鼠标点击里  就包含了鼠标相关的信息
     这个事件对象我们可以自己命名  比如event、e等
     也有兼容性问题：ie678  通过window.event获取事件对象

     事件对象常见属性和方法：e.target 返回的是触发事件的对象(元素) ：点击了哪个元素就返回哪个元素  this返回的是绑定事件的对象(元素)：绑定了谁就返回谁     例子：ul--li   给ul绑定一个事件 currentTarget
     e.type
     阻止默认行为（事件）让连接不跳转或提交按钮不提交
     
     e.preventDefault()   方法    e.returnValue  低版本   return false;也可以实现，但是有弊端 后面代码不会执行了 而且只限于传统的注册方式 a.onclick = function(e){};
     阻止事件冒泡
     e.stopPropagation()方法      window.event.cancelBubble = ture;  低版本
     
* 

* BOM   浏览器对象模型
     **与浏览器窗口进行交互**的对象，核心对象是window（顶级对象）   由一系列对象构成，每个对象都提供了很多方法和属性  BOM包含DOM
     window对象双层身份：1）访问浏览器窗口的一个接口  2）是一个全局对象。全局作用域中的变量和函数都会变成window对象的属性和方法。调用的时候window可以省略（前面所学的alert()   prompt()都是window对象的方法）   注意：window下有一个特殊的属性window.name

* window常用事件与方法
     窗口加载事件：当文档内容全部加载完之后执行的事件    window.onload=function(){}   只能写一个，多个以最后一个为准   window.addEventListener('onload',function(){});
     调整窗口大小事件：窗口大小发生变化就会触发   windwo.onresize =function(){}      window.addEventListener("resize",function(){})     完成响应式布局  window.innerWidth：当前窗口宽度px（放在onresize方法内使用）
     定时器：setTimeout(调用函数，[延迟的秒数---毫秒   省略默认为0]);      setTimeout(function(){},2000);   只执行一次      调用函数也可以写函数名（不带()或者'函数名()'----不提倡）   页面中可能有很多个定时器，所以给定时器起个名字   比如timer
             停止（清除）定时器：clearTimeout(timer)  定时器名字
     定时器：setInterval(调用函数，[延迟的秒数]);  每隔多少秒反复调用
             停止定时器：clearInterval();     null是一个空对象

* 回调函数
     callback    普通函数按照代码顺序直接调用，而定时器这个函数需要等待时间到了才去调用这个函数，因此称为回调函数（上一件事干完，再回头调用）

     * ***案例：京东秒杀倒计时p274     发送短信案例p276
     
* this指向问题
     只有函数执行的时候才能够确定this到底指向谁，一般情况下this的最终**指向的是那个调用它的对象**
     1）全局作用域或者普通函数中的this指向全局对象window（注意：定时器里面的this指向window）
     2）方法中调用中谁调用指向谁
     3）构造函数中this指向构造函数的实例

* JS执行队列：同步和异步
     JS是单线程，同一个时间只能做一件事儿    防止下一个问题等待时间过长HTML5提出了Web Worker标准  提出了同步异步    异步：可以同时执行多个任务
     同步异步本质区别：这条流水线上各个流程的执行顺序不同
     **JS执行机制**：1.先执行执行栈中的同步任务   2.异步任务（回调函数）放入任务队列中   3.一旦执行栈中所有同步任务执行完毕，系统会按次序读取**任务队列**中的异步任务，于是被读取的异步任务结束等待状态，进入**执行栈**开始执行            异步进程处理：符合条件之后才会放到任务队列中（点击后  3000后） 
             事件循环：event loop  主线程不断地从任务队列中获得任务、执行任务、再获取、再执行，所以这种机制被称为事件循环（event loop）   
     JS的异步是通过回调函数实现的：一般而言异步任务有三种：
            普通事件：click、resize等
            资源加载：load、error等
            定时器：setInterval、setTimeout等

* location对象
     window对象下的一个属性，作用：用于获取或设置窗体的url，并且可以用于解析URL   返回一个对象
     URL：统一资源定位符，是互联网上标准资源地址，互联网上每个文件都有唯一的URL

        常见属性：
                **href**：页面的地址 返回整个url   赋一个值就会跳转到相应的地址去
                host：主机名
                **search**：返回参数
                hash：返回代码片段  #后面内容 常见链接 锚点
         常用方法：
                assign()：重定向页面 说白了：往哪里跳 与href功能一致  记录浏览历史可以后退
                replace()：不记录浏览历史  不可以后退

     ​           reload()：重新刷新页面   相当于F5  如果参数为true  相当于ctrl+f5强制刷新

* 案例：跨页面传递数据   form提交方式默认为get

* navigator对象
     包含有关浏览器的信息（如 用PC端打开的还是移动端打开的）
     属性：userAgent  浏览器相关信息   检测用哪个页面打开  然后可以实现跳转location.href跳

* history对象

     与浏览器历史记录进行交互
          常用方法：
                  back()  后退功能
                  forward()  前进功能
                  go(参数)  前进后退功能  看参数传什么   1前进一个页面  -1后退一个页面

* 

* PC端网页特效

     * 元素偏移量offset系列相关属性
          可以**动态**的得到该元素的位置（偏移）、大小等

          获得元素距离带有定位父元素的位置
          获得元素自身的大小（宽度高度）
          返回数值都不带单位
          常用属性：offsetTop
                             offsetLeft
                             offsetWidth：返回包括padding、边框、内容区的宽度，返回数值不带单位
                             offsetHeight：同上  优点：动态获取盒子大小
                             offsetParent：获取带有定位的父元素   否则返回的是body

     * offset和style的区别
          style只能获取行内样式设置的属性值     offset可以得到任意样式
          style获得的是带有单位的字符串             offset获得的是数值没有单位
          style不包含padding和border                 offset包含
          style可读可写属性                                    offset系列是只读属性
          给元素改值style更合适                             获取元素大小offset更合适

     * 获取鼠标在盒子内的坐标    
           相减（简单的数学题）
          e.pageX    e.pageY    鼠标距离body的xy距离（鼠标在页面中的坐标） 放在点击事件中触发
          box.offsetLeft    box.offsetTop     盒子距离body的距离
          鼠标移动事件：mousemove  鼠标移动即可显示鼠标在盒子内的坐标

     * 案例：模态框拖拽

     * 

     * 

     * 

* 

* 

* 

* 

* 

* 

* 

* JS进阶（高级）

     * 作用域    变量能够被访问的范围
          **局部作用域**

           		函数作用域：不同函数之间的变量不能互相使用

           		块级作用域：只要是被{}包裹的代码称为代码块    外面有可能无法被访问   var声明的外边可以被访问   let声明的无法被访问（let、const（常量）声明的变量会产生块作用域，var不会产生块作用域）   推荐使用：let或const
          **全局作用域**

          ​		 在.js或<script>标签中最外层定义   尽量少的使用全局变量，防止全局变量被污染
          **作用域链**

          ​		本质上是底层的变量查找机制

            	  在函数执行时，会优先在当前函数作用域中查找变量
          		如果当前作用域查找不到则会一次逐级查找父级作用域直到全局作用域     父作用域无法访问子集作用域

          **JS垃圾回收机制**（GC）

          ​		js内存的分配和回收是自动完成的，内存在不使用的时候会被垃圾回收器自动回收
          ​		内存的生命周期：内存分配、内存使用、内存回收
          ​		全局变量一般不会回收（关闭页面回收）   一般情况下，局部变量的值不用了会自动回收掉
          ​		内存泄漏：程序中分配的内存由于某种原因程序未释放或无法释放

          ​		垃圾回收机制算法说明：
          ​				引用计数法：
          ​				标记清除法：

          **闭包**

          ​		概念：闭包 = 内存函数+外层函数的变量  （内层函数用到了外层函数的变量）
          ​		

          变量提升

     * 函数进阶

     * 解构和赋值

          * 综合案例

     * 构造函数

          ​		创建对象三种方式：1）字面量方式：const obj = {}   2)利用new Object创建对象  const obj = new Object{}    obj.name='张三'     const obj = new Object({name:'张三'})	3)利用构造函数
          ​		概念：是一种特殊的函数，主要用来初始化对象的 
          ​        使用场景：把几个对象公共的部分抽取出来封装成一个函数，可以通过构造函数来快速创建多个类似的对象
          ​        两个约定：命名以大写字母开头		只能由new操作符来执行（实例化）

          ​		语法格式：function 构造函数名(name,age){ this.name = name; this.age = age } this.属性 = 形参
          ​		无参数时构造函数名后的()可以省略不建议省略	内部无须写return返回值即为新创建的对象  构造函数内部的return是无效的不要写
          ​		new之后就会创建一个空对象

     * new实例化执行过程
              1、创建一个新的空对象  2、this指向新对象 3、执行构造函数，修改this添加新的属性  4、返回新对象

     * 实例成员和静态成员
                  实例成员：实例对象上的属性和方法      构造函数创建的实例对象彼此独立互不影响
                  静态成员：构造函数中的属性和方法     例：Person.name='张三'   Date.now()中Date就是一个构造函数，Math.PI、Math.random
                                     静态成员只能用构造函数名来访问     静态方法中的this指向构造函数

     * 内置构造函数
                   Object
                   Array
                   String
                   Number

     * 

     * 

     * 

     * 

     * 

     * 

     * 

* 

* 

* 虚拟DOM
     本质是Object类型的对象（一般对象）
     虚拟DOM比较'轻'，真实DOM比较'重'，因为虚拟DOM是React内部在用，无需真实DOM那么多的属性
     虚拟DOM最终会被React转化为真实DOM呈现在页面上

* JS中类相关的知识
         关键字：class
         构造器方法：constructor关键字      constructor(name){this.name}   this指向的是类的实例对象（看怎么调用的）   类中的构造器不是必须写的     要对实例进行一些初始化的操作时，如添加指定属性时才写
         类中的方法放在了类的原型对象上，供实例使用      好处：复用
         继承：extend关键字     继承父类的构造器 super(参数)   要放在构造器最前面
         重写从父类继承过来的方法

* 

